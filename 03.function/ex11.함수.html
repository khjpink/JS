<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>
    
    //지역변수 밖에서 호출하면 오류남
    //console.log(msg);

    //전역변수 선언, 초기화 
    let msg2 = "Hello";

    //1.함수선언식
      //호이스팅에 영향을 받는다. 함수 선언문은 코드의 맨위로 끌어올려진다.
      //함수 내에서 전역변수를 호출하는데, 이 변수가 선언되어 있지 않으면 오류가 발생할것이다 

      //호이스팅(Hoisting) : 
        //js에서 변수 및 함수 선언이 컴파일 단계에서 메모리에 끌어올려지는 현상
        //변수 및 함수 선언을 작성한 위치와 상관없이 해당 스코프의 최상단으로 끌어올려지는 것 
          /*
          //함수 선언문의 호이스팅 : 
            //intro()함수 호출하기 전에 함수선언문이 나오지만, 
            //js에서는 함수선언문을 코드의 최상단으로 끌어올리므로 정상적으로 실행됨
          intro();
          function intro(){
            console.log("함수선언")
          }
          //변수 선언문의 호이스팅 : 
            // var x는 호이스팅에 의해 코드의 최상단으로 끌어올려지지만, 초기화는 그 자리에 있게 되므로
            console.log(x); //첫번째 콘솔에서는 undefinded가 출력됨
            var x = 5;
            console.log(x);

          //함수 표현식의 호이스팅 : 
            //함수 표현식과 화살표 함수는 호이스팅 함수 선언문과 다르게 작용함
            //함수 표현식은 변수 선언이 호이스팅되지만, 할당은 그 자리에 남아 있다 
            //함수 선언식과 함수 표현식의 호이스팅 차이는 코드 구조를 작성할 때 고려해야하는 중요한 요소임
          console.log(foo);  //undifinded
          var foo = function(){
            console.log("함수 표현식 호출");
          };
          console.log(foo); // [Function:foo]
          foo(); //함수 표현식 호출
          */

      //스코프(Scope):
        //변수나 함수의 유효 범위
        //js에서는 블록 스코프와 함수 스코프가 있음
        //호이스팅은 이러한 스코프에서 변수 및 함수 선언이 스코프의 최상단으로 끌어올려지는 행동을 말함
          /*
            //함수 스코프에서 변수 호이스팅
              function example() {
                
                //undefined인 이유는 호이스팅 때문이다. 
                //js는 함수 스코프에서 변수 선언을 함수의 최상단으로 끌어올려짐
                //따라서 x는 함수 내에서 어디든지 참조할 수 있음
                console.log(x); 
                var x = 5;

                // 5
                console.log(x); 
              }
              //함수 호출을 해야 위의 콘솔이 출력됨
              example(); 
              

            //블록 스코프에서 변수 호이스팅(let, const)
              function example2(){
                if(true){
                  //let과 const는 블록스코프를 가지기 때문에 
                  //블록 내에서 선언된 변수는 블록 시작 지점까지 호이스팅되지만
                  //초기화는 그 자리에서 이루어진다
                  //따라서 Cannot access 'x' before initialization 에러가 발생한다 
                  console.log(x); // ReferenceError: Cannot access 'x' before initialization
                  
                  let x = 5;
                  console.log(x); // 5
                }
              }
              example2();
          */
    function intro(){
      console.log("intro()함수가 실행됨");

      //지역변수 선언, 초기화 
      let msg = "function!";
      console.log("지역변수",msg);

      //전역변수 호출
      console.log("전역변수",msg2);
    }
    intro();
    //전역변수 호출
    console.log("전역변수",msg2);
    

    //2.함수표현식 = 익명함수
      //변수에 함수를 할당한다 
      //변수를 통해서 호출한다 
    let intro2 = function(){
      console.log("익명함수 실행");
    }
    intro2();

    //3.화살표 함수
      //ES6에서 도입한 새로운 함수 표현식
      //함수 내부의 this가 자동으로 바인딩되어, 일반 함수 표현식보다는 this의 문제에 대해 더 편리함
    let intro3 = () => {
      console.log("화살표함수 실행");
    }
    intro3();


    //4.결론
    //함수의 호이스팅, 스코프, this 바인딩 등을 고려하여 선택하면 됩니다.
    //함수 선언식과 변수 선언문은 호이스팅에 영향을 받지만
    //함수 표현식, 화살표 함수, let, const로 선언된 변수를 블록 스코프를 가지며 호이스팅 동작이 다르다 
    
  </script>

</body>
</html>